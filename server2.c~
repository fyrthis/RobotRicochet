#include <stdio.h>
#include <stdlib.h>

#include <netdb.h>
#include <netinet/in.h>

#include <string.h>

#include <unistd.h> //for sleep

void doprocessing (int sock);
//int *socks = (int*)malloc(2*sizeof(int));
int socks[2];
int cpt = 0;

int main( int argc, char *argv[] ) {
   int sockfd, newsockfd, portno, clilen;
   char buffer[256];
   struct sockaddr_in serv_addr, cli_addr;
   int n, pid;
   
   /* First call to socket() function */
   sockfd = socket(AF_INET, SOCK_STREAM, 0);
   
   if (sockfd < 0) {
      perror("ERROR opening socket");
      exit(1);
   }
   
   /* Initialize socket structure */
   bzero((char *) &serv_addr, sizeof(serv_addr));
   portno = 2018;
   
   serv_addr.sin_family = AF_INET;
   serv_addr.sin_addr.s_addr = INADDR_ANY;
   serv_addr.sin_port = htons(portno);
   
   /* Now bind the host address using bind() call.*/
   if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
      perror("ERROR on binding");
      exit(1);
   }
   
   /* Now start listening for the clients, here
      * process will go in sleep mode and will wait
      * for the incoming connection
   */
   
   listen(sockfd,5);
   clilen = sizeof(cli_addr);
   
   while (1) {
      newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
		
      if (newsockfd < 0) {
         perror("ERROR on accept");
         exit(1);
      }
      
      /* Create child process */
      pid = fork();
		
      if (pid < 0) {
         perror("ERROR on fork");
         exit(1);
      }
      
      if (pid == 0) {
         /* This is the client process */
         close(sockfd);
         doprocessing(newsockfd);
         exit(0);
      }
      else {
         close(newsockfd);
      }
		
   } /* end of while */
}

void doprocessing (int sock) {
socks[0] = sock;
printf("sock : %d == %d", sock, socks[cpt]);
cpt++;

   int n;
   char buffer[256];
   bzero(buffer,256);
   n = read(sock,buffer,255);
   
   if (n < 0) {
      perror("ERROR reading from socket");
      exit(1);
   }

   //From buffer : check if syntaxe is correct, if username is alphanumeric, and extract username
   char * pch;
   printf ("Splitting string \"%s\" into tokens:\n",buffer);
   pch = strtok (buffer,"/");
   int i = 0;
   char* username = NULL;
   do{
      if(pch==NULL) printf("ERROR : received shit\n");
      if(strcmp(pch,"CONNEXION")==0 && i==0) {
         printf ("Asked for %s : ",pch);
      } else
      if(i==1) {
         printf("from user %s\n", pch);
         username = (char*)malloc(sizeof(pch));
         strncpy(username, pch, sizeof(pch));
         break;
      } else
         printf("ERROR : syntax should be CONNEXION/username/\n");
      i++;
      pch = strtok (NULL, "/");
      
   }while (pch != NULL);
   
   printf("Here is the user: %s\n",username);
   char *msg = (char*)malloc((12+strlen(username))*sizeof(char));
   strcpy(msg, "BIENVENUE/");
   strcat(msg, username);
   strcat(msg,"/\n");
printf("%s", msg);
   n = write(sock,msg,strlen(msg)*sizeof(char));
   
   if (n < 0) {
      perror("ERROR writing to socket");
      exit(1);
   }

char coucou[8];
strcpy(coucou, "coucou\r\n");
//strcat(coucou, "\n");
n = write(sock,coucou,sizeof(coucou));
   if (n < 0) {
      perror("ERROR writing to socket");
      exit(1);
   }
n = write(sock,coucou,sizeof(coucou));
   if (n < 0) {
      perror("ERROR writing to socket");
      exit(1);
   }
n = write(sock,coucou,sizeof(coucou));
   if (n < 0) {
      perror("ERROR writing to socket");
      exit(1);
   }
   
//Attendre un message client
   n = read(sock,buffer,255);
   pch = strtok (buffer,"/");
   i = 0;
   do{
      if(pch==NULL) printf("ERROR : received shit\n");
      if(strcmp(pch,"SORT")==0 && i==0) {
         printf ("Asked for %s : ",pch);
      } else
      if(strcmp(pch,username)==0 && i==1) {
         printf("from user %s\n", pch);
         break;
      } else
         printf("ERROR : %s\n", pch);
      i++;
      pch = strtok (NULL, "/");
      
   }while (pch != NULL);


   //DIRE A TOUT LE MONDE QUE USERNAME EST CONNECTE.
   //TODO
	
}
