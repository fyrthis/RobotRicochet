#include <stdio.h>       /* standard I/O routines                     */
#define __USE_GNU 
#include <pthread.h>     /* pthread functions and data structures     */

#include <stdlib.h>      /* rand() and srand() functions              */

#include <netdb.h>
#include <netinet/in.h>
#include <string.h>
/* number of threads used to service requests */


#define NB_MAX_THREADS 8
#define NB_MAX_CLIENTS 50

pthread_mutex_t request_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
pthread_cond_t  got_request   = PTHREAD_COND_INITIALIZER;

int nbTask = 0;

typedef struct task {
    int number; //num de la tache ?
    int socket; //numero de la socket
    char * name; //Client's name
    void (*func_ptr)(void*,...); //Function to execute
    struct task * next;
}task_t;

task_t * requests = NULL;
task_t * last_request = NULL;

//TODO : fonction qui dit bienvenue, et annonce à tous les joueurs le nouveau joueur.
void connect1(char * name);
//TODO : fonction qui déconnecte le joueur, met à jour la liste des joueurs, et l'annonce aux joueurs.
void disconnect1(char * name);
//TODO : Fonction qui démarre une session
//TODO : etc...

void addTask(void (*func)/*(void *)*/, pthread_mutex_t* p_mutex, pthread_cond_t*  p_cond_var) {
    int rc;
    task_t * a_request;

    /* create structure with new request */
    a_request = (task_t*)malloc(sizeof(task_t));
    if (!a_request) { /* malloc failed?? */
	fprintf(stderr, "add_request: out of memory\n");
	exit(1);
    }
    //a_request->number = request_num;
    a_request->func_ptr = func;
    a_request->next = NULL;

    rc = pthread_mutex_lock(p_mutex);

    if (nbTask == 0) {
	requests = a_request;
	last_request = a_request;
    }
    else {
	last_request->next = a_request;
	last_request = a_request;
    }

    nbTask++;

    printf("add_request: added request with id '%d'\n", a_request->number);
    fflush(stdout);

    /* unlock mutex */
    rc = pthread_mutex_unlock(p_mutex);

    /* signal the condition variable - there's a new request to handle */
    rc = pthread_cond_signal(p_cond_var);
}

task_t * getTask(pthread_mutex_t* p_mutex) {
    int rc;
    task_t * a_request;

    rc = pthread_mutex_lock(p_mutex);

    if (nbTask > 0) {
	a_request = requests;
	requests = a_request->next;
	if (requests == NULL) {
	    last_request = NULL;
	}
	nbTask--;
    }
    else {
	a_request = NULL;
    }

    /* unlock mutex */
    rc = pthread_mutex_unlock(p_mutex);

    /* return the request to the caller. */
    return a_request;
}

void handle_request(task_t * a_request, int thread_id) {
    if (a_request) {
        char *str = (char*)malloc(10*sizeof(char));
        //sprintf(str, "task %d", a_request->number);
        //if(a_request->number%2==0)
        //    connect1(str);
        //else
        //    disconnect1(str);
        a_request->func_ptr("toto");
	printf("Thread '%d' handled request '%d'\n",
	       thread_id, a_request->number);
	fflush(stdout);
    }
}


void * handle_requests_loop(void* data) {
    int rc;
    task_t * taskWeDo;
    int thread_id = *((int*)data);

    /* lock the mutex, to access the requests list exclusively. */
    rc = pthread_mutex_lock(&request_mutex);

    while (1) {
	if (nbTask > 0) { /* a request is pending */
	    taskWeDo = getTask(&request_mutex);
	    if (taskWeDo) { /* got a request - handle it and free it */
		handle_request(taskWeDo, thread_id);
		free(taskWeDo);
	    }
	}
	else {
	    rc = pthread_cond_wait(&got_request, &request_mutex);
	}
    }
}

int main(int argc, char* argv[]) {
    //INITIALIZE SERVER
    printf("Initialize server...\n");
    printf("Initialize threads...\n");
    int        i;                                /* loop counter          */
    int        thr_id[NB_MAX_THREADS];                /* thread IDs            */
    pthread_t  p_threads[NB_MAX_THREADS];             /* thread's structures   */
    for (i=0; i<NB_MAX_THREADS; i++) {
	thr_id[i] = i;
	pthread_create(&p_threads[i], NULL, handle_requests_loop, (void*)&thr_id[i]);
        printf("Thread %d created and ready\n", i);
    }
    printf("Initialize server socket...\n");
    int port = 2016;
    int socket_server;
    int socket_client;
    struct sockaddr_in server_address;
    struct sockaddr_in client_address = { 0 };
    int client_size = sizeof(client_address);
    if(argc>1) {
        port = atoi(argv[1]);
    }
    printf("setting port : %d\n", port);
    socket_server = socket(AF_INET, SOCK_STREAM, 0);
   
    if (socket_server < 0) {
        perror("ERROR opening server socket\n");
        exit(1);
    } else {
        puts("The server socket is now open\n");
    }

    bzero((char *) &server_address, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(port);
    if (bind(socket_server, (struct sockaddr *) &server_address, sizeof(server_address)) < 0) {
       perror("ERROR on binding\n");
       exit(1);
    }

    printf("Start listenning with %d simultaneously clients max\n",NB_MAX_CLIENTS);
    while(1) {
        listen(socket_server,NB_MAX_CLIENTS);
        socket_client = accept(socket_server, (struct sockaddr *) &client_address, &client_size);
        //Nouvelle connexion
        addTask(connect1, &request_mutex, &got_request);

    }

    
    return 0;
}

void connect1(char * name) {
    printf("connect %s\n", name);
}

void disconnect1(char * name) {
    printf("disconnect %s\n", name);
}

